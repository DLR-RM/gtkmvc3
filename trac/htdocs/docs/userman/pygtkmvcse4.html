<html > 
<head><title> MVC&#8211;O Infrastructure</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,2,info,next,mouseover,no-DOCTYPE --> 
<meta name="src" content="pygtkmvc.tex"> 
<meta name="date" content="2009-03-31 17:46:00"> 
<link rel="stylesheet" type="text/css" href="pygtkmvc.css"> 
<script type="text/javascript" src="pygtkmvc-js.js"></script> 
<script type="text/javascript" src="overlib.js"><!-- overLIB (c) Erik Bosrup --></script> <!--http://www.bosrup.com/web/overlib/--></head><body 
><div id="overDiv" style="position:absolute; visibility:hidden; z-index:1000;"></div> 
   <!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="pygtkmvcse7.html" >next</a>] [<a 
href="pygtkmvcse4.html" >prev</a>] [<a 
href="pygtkmvcse4.html#tailpygtkmvcse4.html" >prev-tail</a>] [<a 
href="pygtkmvcse3.html#tailpygtkmvcse4.html">tail</a>] [<a 
href="pygtkmvc.html#pygtkmvcse5.html" >up</a>] </p></div>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x7-50004"></a> <span 
class="cmti-10">MVC&#8211;O </span>Infrastructure</h3>
<!--l. 4--><p class="noindent" >The <span 
class="cmti-10">MVC&#8211;O </span>framework provides a simplified and modified implementation of the
<span 
class="cmti-10">MVC </span>pattern, and a very straightforward implementation of the <span 
class="cmti-10">Observer</span>
pattern.
<!--l. 7--><p class="indent" >   In the following a detailed description of each pattern is provided. However, it is
important to pinpoint here that the patterns have not been implemented
in a rigorous way. Instead, they have been adapted to the particular way
<span 
class="cmsl-10">PyGTK </span>based application are designed, making the framework <span 
class="cmti-10">easy </span>and
<span 
class="cmti-10">practical </span>to be used instead of being fully compliant with the theoretical
patterns.
<!--l. 1--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x7-60004.1"></a> Implementation of the <span 
class="cmti-10">MVC </span>pattern</h4>
<!--l. 3--><p class="noindent" >The implementation of the <span 
class="cmti-10">MVC </span>pattern provided by <span 
class="cmti-10">gtkmvc </span>is a dialect version of
the &#8220;official&#8221; pattern generally described by Software Engineering Theory
<span class="footnote-mark"><a 
href="pygtkmvc8.html#fn2x0"  
onmouseover="tex4ht.body=tex4ht.fn2x0; tex4ht.caption='2'; return overlib(tex4ht.body,FULLHTML);"  
onmouseout="nd();" 
 
 ><sup class="textsuperscript">2</sup></a></span><a 
 id="x7-6001f2"></a>.
<!--l. 8--><p class="indent" >   <hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>

<a 
 id="x7-60022"></a>

<div class="center" 
>
<!--l. 9--><p class="noindent" >

<!--l. 10--><p class="noindent" ><img 
src="figs/png/mvc.png" alt="PIC"  
>
<br /> <table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;2: </td><td  
class="content">Simplified Model-View-Controller Pattern</td></tr></table><!--tex4ht:label?: x7-60022 -->
</div>

<!--l. 13--><p class="indent" >   </td></tr></table></div><hr class="endfigure">
<!--l. 14--><p class="indent" >   The implementation is different as the view side cannot see the model part. The
reasons behind this difference will be explained later, but we can anticipate here
that this is due to the relationship between the view and the controller,
that is stronger in <span 
class="cmti-10">gtkmvc </span>than in the classic <span 
class="cmti-10">MVC </span>pattern. To a certin
extend, in <span 
class="cmti-10">gtkmvc </span>the view and the controller parts are separate but could be
considered as a unique entity. However, a view can have multiple controllers (or
a single controller decomposed into many sub-controllers for the sake of
semplicity).
<!--l. 26--><p class="indent" >   Figure <a 
href="#x7-60022">2<!--tex4ht:ref: MVC_f --></a> shows three interconnected parts:
     <dl class="description"><dt class="description">
<span 
class="cmbx-10">Model</span> </dt><dd 
class="description">Contains  the  <span 
class="cmti-10">state  </span>(the  <span 
class="cmti-10">logic</span>)  of  the  application.  Also  it  provides
     support  to  access  and  modify  the  state,  and  knows  how  to  handle
     dependencies  between  different  parts  in  the  state.  For  example  the
     application logic could require that changing a variable, causes a changing
     of  another.  It  is  not  required  the  model  user  to  be  aware  about  this
     dependency, because model autonomously handles it.
     <!--l. 37--><p class="noindent" >Zero,  one  or  more  <span 
class="cmti-10">Controllers  </span>can  be  connected  to  one  Model  (see
     <span 
class="cmti-10">Controller</span>, below). Furthermore, one or more <span 
class="cmti-10">Views </span>can be associated with
     parts of the state; for example a numerical variable could be visualized as
     a number, as well as a graphic bar. It is important to remark that <span 
class="cmti-10">a Model</span>
     <span 
class="cmti-10">does not know that a set of Views is possibly connected to its state through</span>
     <span 
class="cmti-10">a set of Controllers</span>.
     </dd><dt class="description">
<span 
class="cmbx-10">View</span> </dt><dd 
class="description">shows parts of the Model state, and interactively exchanges information
     with the User, via input/output devices. A view can be dcomposed into
     sub-views to simplify the design and the reuse. A View collects a set of
     widget trees built from a <span 
class="cmsl-10">Glade </span>file, and/or constructed by hand. Since
     a Widget contains a <span 
class="cmti-10">state</span>, this implementation differs from the standard
     <span 
class="cmti-10">MVC </span>pattern, where generally the View side is completely <span 
class="cmti-10">stateless</span>.
     <!--l. 54--><p class="noindent" >The View also interacts with zero, one or more <span 
class="cmti-10">Controllers </span>(see below),
     sending to it signals, and receiving information to visualize.
     <!--l. 58--><p class="noindent" >A View does not know the semantics concerning what it visualizes, and
     neither knows that it is possibly connected to a set of controllers.
     </dd><dt class="description">
<span 
class="cmbx-10">Controller</span> </dt><dd 
class="description">Realizes the connection between Models and Views. A Controller
     contains the <span 
class="cmti-10">GUI </span>logic: for example, it stores the information about what
     happens when a button is clicked (e.g. handlers of signal are located inside
     a Controller.)
     <!--l. 67--><p class="noindent" >A Controller perfectly knows the interfaces of the connected Model and
     View, and knows both the state and presentation (<span 
class="cmti-10">GUI</span>) semantics. A
     Controller is associated to one Model (<span 
class="cmti-10">use a  </span>relationship), and in the

     current implementation is associated only to one View (<span 
class="cmti-10">has a </span>relationship).
     A Controller may grow in size, thus it is important to avoid including
     into  the  Controller  code  and  information  that  should  resize  into  the
     Model.  Also  Controller  can  be  simplified  by  decomposing  them  into
     sub-controllers, each controlling a subset of the View.
     </dd></dl>
<!--l. 79--><p class="indent" >   Two particular mechanisms make the isolation between Model and Controller,
and between View and Controller. To support the former, the <span 
class="cmti-10">Observer </span>pattern is
provided (see <a 
href="#x7-80004.2">4.2<!--tex4ht:ref: OBS --></a>), whereas latter mechanism is provided by the <span 
class="cmti-10">MVC </span>pattern, and
that is explained in <a 
href="#x7-70004.1.1">4.1.1<!--tex4ht:ref: VR --></a>.
   <h5 class="subsubsectionHead"><span class="titlemark">4.1.1   </span> <a 
 id="x7-70004.1.1"></a> View Registration</h5>
<!--l. 86--><p class="noindent" >Current implementation allows a N-1 relationship between Controller and View.
More clearly, one view can have multiple controllers associated to it, meaning that a
View can be shared among several Controllers. A typical design for large views and
controllers makes a View be split into sets (not necessarily partitions) and each set is
controller by a sub-controller.
<!--l. 93--><p class="indent" >   After a model and a view have been instantiated (model and view are
<span 
class="cmti-10">independent</span>, a controller can be constructed by passing them.
<!--l. 96--><p class="indent" >   From there on, the Controller can access the model, and teh view state (the
set of contained widgets). When the view registers itself with a Controller,
all signals are also automatically connected to the corresponding methods
inside the Controller. Connection in this case is performed by means of an
implicit syntax rule, which binds a signal name to a corresponding method
name.
<!--l. 103--><p class="indent" >   In sections <a 
href="pygtkmvcse5.html#x9-150005.3.2">5.3.2<!--tex4ht:ref: VR:D --></a> and <a 
href="pygtkmvcse5.html#x9-200005.4.4">5.4.4<!--tex4ht:ref: VR:EX --></a> more details and an example are presented, to show
how the View registration mechanism can be exploited by controllers to connect
signals and handle the creation of particular widgets like for example TreeViews,
TreeColumns, CellRenderers, etc.
<!--l. 1--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.2   </span> <a 
 id="x7-80004.2"></a> Implementation of the <span 
class="cmti-10">Observer </span>pattern</h4>
<!--l. 3--><p class="noindent" >A Model does not know that it is connected to a set of controllers, because this
knowledge implies the knowledge of the <span 
class="cmti-10">GUI </span>semantics, which has to be out-of-scope
for the Model.
<!--l. 7--><p class="indent" >   Nevertheless, sometimes it is necessary for a Model to communicate to the <span 
class="cmti-10">GUI</span>
logics (generally the Controllers set) that the model state changed. This
communication can be implemented by the <span 
class="cmti-10">Observer </span>pattern, that provides a
mechanism where <span 
class="cmti-10">Observers </span>are notified when <span 
class="cmti-10">observed </span>state in the model get
changed.
<!--l. 13--><p class="indent" >   Even if models are typically observed by the <span 
class="cmti-10">GUI </span>logics, the mechanism can be
used also to decouple (isolate) models and other entities in the application logics. For

example, models can be observed by other models.
<!--l. 18--><p class="indent" >   In <span 
class="cmti-10">gtkmvc </span>Models&#8217; state has been extended with a mechanism called <span 
class="cmti-10">Observable</span>
<span 
class="cmti-10">Properties</span>. An observable property is a part of the Model state which is also
externally observable via an <span 
class="cmti-10">Observer</span>. Every time an observable property changes,
any interested Observer will be notified of the event.
<!--l. 24--><p class="indent" >   Figure <a 
href="#x7-80013">3<!--tex4ht:ref: F:OBS --></a> shows a Model (<span 
class="cmti-10">Model1</span>) containing an observable property
(<span 
class="cmti-10">color</span>). There are also a Controller and a View (to show the colour), and
the Controller is also an observer of <span 
class="cmti-10">Model1</span>. Furthermore, there is another
Observer that is model <span 
class="cmti-10">Model2</span>, whose state the designer wanted to make
dependent on the state of <span 
class="cmti-10">Model1</span>, but without explicitly coupling the two
models.
<!--l. 31--><p class="indent" >   When the property <span 
class="cmti-10">color </span>changes for example to red, all connected Observers will
be notified. Each observer will then perform the necessary operation according to the
respective logics. For example, the Controller will make the connected View showing
the occurred change.
<!--l. 37--><p class="indent" >   <hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>

<a 
 id="x7-80013"></a>

<div class="center" 
>
<!--l. 38--><p class="noindent" >

<!--l. 39--><p class="noindent" ><img 
src="figs/png/obs.png" alt="PIC"  
>
<br /> <table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;3: </td><td  
class="content">Observable models and Observers</td></tr></table><!--tex4ht:label?: x7-80013 -->
</div>

<!--l. 42--><p class="indent" >   </td></tr></table></div><hr class="endfigure">
<!--l. 44--><p class="indent" >   Each Observer declares it is interested in receiving notifications on one or more
properties changing, by a mechanism called <span 
class="cmti-10">Registration</span>. Once an Observer (for
example, a Controller) registered itself with the Model it is associated with, it will be
notified of all changes of the observable properties. The Observers will be
notified only of the property changes that they are actually interested in
observing.
<!--l. 52--><p class="indent" >   An implicit syntactical rule binds observable property names to notifications
sockets inside Observers. This rule allows an automatic connection, and fixes a sort of
&#8220;rule&#8221; for methods names.
<!--l. 56--><p class="indent" >   Later in this document, some implementation details are discussed, and further
details about observable properties are presented. Finally, an example in the latest
part should make all these concepts clearer.
<!--l. 60--><p class="indent" >   <span 
class="cmti-10">Adapters </span>(see section <a 
href="pygtkmvcse7.html#x11-300007">7<!--tex4ht:ref: ADAPT --></a> are powerful entities that can be used to automatically
bind part of the view with part of the model with a minimal effort, without any need
to couple with complex code and naming rules. However, <span 
class="cmti-10">Adapters </span>should be used
only after all the &#8220;manual&#8221; mechanisms have been well understood, and for this
reason they are presented only at the end of this document.
   <h5 class="subsubsectionHead"><span class="titlemark">4.2.1   </span> <a 
 id="x7-90004.2.1"></a> Supported types of Observable Properties</h5>
<!--l. 70--><p class="noindent" >Observable properties can hold several types of values:
<!--l. 72--><p class="indent" >
     <dl class="description"><dt class="description">
<span 
class="cmbx-10">Any type</span> </dt><dd 
class="description">Change notification will occur only when the value is <span 
class="cmti-10">assigned </span>to
     the property.
     </dd><dt class="description">
<span 
class="cmbx-10">Mutable sequential types</span> </dt><dd 
class="description">Like  lists  and  maps.  A  notification  will  occur
     when the <span 
class="cmti-10">content  </span>of the object changes, e.g. when one element of the
     sequence is assigned, added, removed, etc.
     </dd><dt class="description">
<span 
class="cmbx-10">User classes</span> </dt><dd 
class="description">The user can declare the set of methods that can be observed (i.e.
     observables will be notified before and/or after observed object <span 
class="cmti-10">methods</span>
     are called.)
     </dd><dt class="description">
<span 
class="cmbx-10">Events</span> </dt><dd 
class="description">To notify the observers that some event is occurred.</dd></dl>
<!--l. 87--><p class="indent" >   All needed details about observable property types are explained later in this
document (see section <a 
href="pygtkmvcse5.html#x9-220005.5.1">5.5.1<!--tex4ht:ref: KOBS:DET --></a>).
<!--l. 73--><p class="indent" >


   <!--l. 4--><div class="crosslinks"><p class="noindent">[<a 
href="pygtkmvcse7.html" >next</a>] [<a 
href="pygtkmvcse4.html" >prev</a>] [<a 
href="pygtkmvcse4.html#tailpygtkmvcse4.html" >prev-tail</a>] [<a 
href="pygtkmvcse4.html" >front</a>] [<a 
href="pygtkmvc.html#pygtkmvcse5.html" >up</a>] </p></div>
<!--l. 4--><p class="indent" >   <a 
 id="tailpygtkmvcse4.html"></a>    
</body></html> 
