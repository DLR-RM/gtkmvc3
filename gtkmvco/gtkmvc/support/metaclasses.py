#  Author: Roberto Cavada <cavada@fbk.eu>
#
#  Copyright (c) 2005 by Roberto Cavada
#
#  pygtkmvc is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
#  pygtkmvc is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA 02110, USA.
#
#  For more information on pygtkmvc see <http://pygtkmvc.sourceforge.net>
#  or email to the author Roberto Cavada <cavada@fbk.eu>.
#  Please report bugs to <cavada@fbk.eu>.

import new
import re
import types

import gtkmvc.support.wrappers as wrappers
from gtkmvc.support.utils import get_function_from_source
from gtkmvc.support.log import logger


# ----------------------------------------------------------------------

OBS_TUPLE_NAME = "__observables__"

# old name, supported only for backward compatilibity, do not use it
# anymore in new code
PROPS_MAP_NAME = "__properties__" 

# This keeps the names of all observable properties (old and new)
ALL_OBS_SET = "__all_observables__"


class PropertyMeta (type):
    """This is a meta-class that provides auto-property support.
    The idea is to allow programmers to define some properties which
    will be automatically connected to auto-generated code which handles
    access to those properties.
    How can you use this meta-class?
    First, '__metaclass__ = PropertyMeta' must be class member of the class
    you want to make the automatic properties handling.
    Second, '__properties__' must be a map containing the properties names
    as keys, values will be initial values for properties.
    That's all: after the instantiation, your class will contain all properties
    you named inside '__properties__'. Each of them will be also associated
    to a couple of automatically-generated functions which get and set the
    property value inside a generated member variable.
    About names: suppose the property is called 'x'.  The generated variable
    (which keeps the real value of the property x) is called _prop_x.
    The getter is called get_prop_x(self), and the setter is called
    'set_prop_x(self, value)'.

    Customization:
    The base implementation of getter is to return the value stored in the
    variable associated to the property. The setter simply sets its value.
    Programmers can override basic behaviour for getters or setters simply by
    defining their getters and setters (see at the names convention above).
    The customized function can lie everywhere in the user classes hierarchy.
    Every overridden function will not be generated by the metaclass.

    To supply your own methods is good for few methods, but can result in a
    very unconfortable way for many methods. In this case you can extend
    the meta-class, and override methods get_[gs]etter_source with your
    implementation (this can be probably made better).
    An example is provided in meta-class PropertyMetaVerbose below.
    """
    
    def __init__(cls, name, bases, _dict):
        """class constructor"""
        properties = {}
        type.__init__(cls, name, bases, _dict)
       
        # the set of all obs (it is calculated and stored below)
        obs = set()

        # Generates code for all properties (but not for derived props):
        props = getattr(cls, PROPS_MAP_NAME, {})            
        for prop in props.keys():
            type(cls).__create_prop_accessors__(cls, prop, props[prop])
            obs.add(prop)
            pass

        # processes now all names in __observables__ 
        for prop in type(cls).__get_observables_array__(cls):
          type(cls).__create_prop_accessors__(cls, prop, _dict.get(prop, None))
          obs.add(prop)
          pass

        # generates the list of _all_ properties available for this
        # class (also from bases)
        for base in bases: obs |= getattr(base, ALL_OBS_SET, set())
        setattr(cls, ALL_OBS_SET, obs)
        return


    def __get_observables_array__(cls):
        """Returns an array of strings by expanding wilcards found
        in class field __observables__. Expansion works only with
        names not prefixed with __"""
        import fnmatch
        res_set = set() # this is used for performances
        res = [] # this is used to keep ordering

        not_found = []
        for name in getattr(cls, OBS_TUPLE_NAME, tuple()):
            if hasattr(cls, name):
                if getattr(cls, name) != types.MethodType: 
                    res.append(name)
                    res_set.add(name)
                    pass
                
            else: not_found.append(name)
            pass

        # now searches all possible matches for those that have not been found:
        for name in (x for x,v in cls.__dict__.iteritems()
                     if not x.startswith("__") 
                     and type(v) != types.MethodType
                     and x not in res_set):
            for pat in not_found:
                if fnmatch.fnmatch(name, pat): res.append(name); res_set.add(name)
                pass
            pass
        
        return res

        
    def __create_prop_accessors__(cls, prop_name, default_val):
        """Private method that creates getter and setter, and the
        corresponding property"""
        getter_name = "get_prop_%s" % prop_name
        setter_name = "set_prop_%s" % prop_name

        members_names = cls.__dict__.keys()

        # checks if accessors are already defined:
        if getter_name not in members_names:
            src = type(cls).get_getter_source(cls, getter_name, prop_name)
            func = get_function_from_source(src)
            setattr(cls, getter_name, func)
        else:
            logger.debug("Custom member '%s' overloads generated getter of property '%s'", 
                         getter_name, prop_name)
            pass

        if setter_name not in members_names:
            src = type(cls).get_setter_source(cls, setter_name, prop_name)
            func = get_function_from_source(src)
            setattr(cls, setter_name, func)
        else:
            logger.warning("Custom member '%s' overloads generated setter of property '%s'",
                           setter_name, prop_name)
            pass

        prop = property(getattr(cls, getter_name), getattr(cls, setter_name))
        setattr(cls, prop_name, prop)

        varname = "_prop_%s" % prop_name
        if not varname in members_names: cls.__create_property(varname, default_val)
        else: logger.warning("Automatic property builder found a possible clashing for variable %s inside class %s",
                             varname, cls.__name__)
        return

    def __create_property(cls, name, default_val):
        setattr(cls, name, cls.create_value(name, default_val))
        return

    def check_value_change(cls, old, new):
        """Checks whether the value of the property changed in type
        or if the instance has been changed to a different instance.
        If true, a call to model._reset_property_notification should
        be called in order to re-register the new property instance
        or type"""
        return  type(old) != type(new) or \
               isinstance(old, wrappers.ObsWrapperBase) and (old != new)
    
    def create_value(cls, prop_name, val, model=None):
        """This is used to create a value to be assigned to a
        property. Depending on the type of the value, different values
        are created and returned. For example, for a list, a
        ListWrapper is created to wrap it, and returned for the
        assignment. model is different from model when the value is
        changed (a model exists). Otherwise, during property creation
        model is None"""

        if isinstance(val, tuple):
            # this might be a class instance to be wrapped
            if len(val) == 3 and \
               isinstance(val[1], val[0]) and \
               (isinstance(val[2], tuple) or isinstance(val[2], list)):
                res = wrappers.ObsUserClassWrapper(val[1], val[2])
                if model: res.__set_model__(model, prop_name)
                return res
            pass
        
        elif isinstance(val, list):
            res = wrappers.ObsListWrapper(val)
            if model: res.__set_model__(model, prop_name)
            return res

        elif isinstance(val, dict):            
            res = wrappers.ObsMapWrapper(val)
            if model: res.__set_model__(model, prop_name)
            return res

        return val


    # ------------------------------------------------------------
    #               Services    
    # ------------------------------------------------------------

    # Override these:
    def get_getter_source(cls, getter_name, prop_name):
        """This must be overridden if you need a different implementation.
        Simply the generated implementation returns the variable name
        _prop_name"""

        return "def %s(self): return self._prop_%s" % (getter_name, prop_name)
    
    def get_setter_source(cls, setter_name, prop_name):
        """This must be overridden if you need a different implementation.
        Simply the generated implementation sets the variable _prop_name"""
        return "def %s(self, val):  self._prop_%s = val" \
               % (setter_name, prop_name)
       
    pass # end of class
# ----------------------------------------------------------------------


# What follows underneath is a set of examples of usage

## class PropertyMetaVerbose (PropertyMeta):
##     """An example of customization"""
##     def get_getter_source(cls, getter_name, prop_name):
##         return "def %s(self): print 'Calling %s!'; return self._prop_%s" \
##                % (getter_name, getter_name, prop_name)

##     def get_setter_source(cls, setter_name, prop_name):
##         return "def %s(self, val):  print 'Calling %s!'; self._prop_%s = val;" \
##                % (setter_name, setter_name, prop_name)
##     pass #end of class
# ----------------------------------------------------------------------
    
## class User:
##     """An example of usage"""
##     __metaclass__ = PropertyMetaVerbose
##     __properties__ = {'x':10, 'y':20}

##     def __init__(self):
##         print self.x         # x is 10
##         self.x = self.y + 10 # x is now 30
##         return
##     pass
# ----------------------------------------------------------------------



class ObservablePropertyMeta (PropertyMeta):
  """Classes instantiated by this meta-class must provide a method named
  notify_property_change(self, prop_name, old, new)"""
  def __init__(cls, name, bases, dict):
    PropertyMeta.__init__(cls, name, bases, dict)
    return    
    
  def get_setter_source(cls, setter_name, prop_name):
    return """def %(setter)s(self, val): 
 old = self._prop_%(prop)s
 new = type(self).create_value('%(prop)s', val, self)
 self._prop_%(prop)s = new
 if type(self).check_value_change(old, new): self._reset_property_notification('%(prop)s')
 self.notify_property_value_change('%(prop)s', old, val)
 return
""" % {'setter':setter_name, 'prop':prop_name}

  pass #end of class


class ObservablePropertyMetaMT (ObservablePropertyMeta):
  """This class provides multithreading support for accesing
  properties, through a locking mechanism. It is assumed a lock is
  owned by the class that uses it. A Lock object called _prop_lock
  is assumed to be a member of the using class. see for example class
  ModelMT"""
  def __init__(cls, name, bases, dict):
    ObservablePropertyMeta.__init__(cls, name, bases, dict)
    return 
    
  def get_setter_source(cls, setter_name, prop_name):
    return """def %(setter)s(self, val): 
 old = self._prop_%(prop)s
 new = type(self).create_value('%(prop)s', val, self)
 self._prop_lock.acquire()
 self._prop_%(prop)s = new
 self._prop_lock.release()
 if type(self).check_value_change(old, new): self._reset_property_notification('%(prop)s')
 self.notify_property_value_change('%(prop)s', old, val)
 return
""" % {'setter':setter_name, 'prop':prop_name}

  pass #end of class


try:
  from sqlobject import Col
  from sqlobject.inheritance import InheritableSQLObject
  from sqlobject.events import listen, RowUpdateSignal
  
  class ObservablePropertyMetaSQL (ObservablePropertyMeta, InheritableSQLObject.__metaclass__):
    """Classes instantiated by this meta-class must provide a method named
    notify_property_change(self, prop_name, old, new)"""

    def __init__(cls, name, bases, dict):
      InheritableSQLObject.__metaclass__.__init__(cls, name, bases, dict)
      ObservablePropertyMeta.__init__(cls, name, bases, dict)

      listen(cls.update_listener, cls, RowUpdateSignal)
      return    

    def __create_prop_accessors__(cls, prop_name, default_val):
      if not isinstance(default_val, Col):
        # this is not a SQLObject column (likely a normal
        # observable property)
        ObservablePropertyMeta.__create_prop_accessors__(cls, prop_name, default_val)
        pass
      return
    
    def update_listener(cls, instance, kwargs):
      pnames = type(cls).__get_observables_array__(cls)
      for k in kwargs:
        if k in pnames:
          _old = getattr(instance, k)
          _new = kwargs[k]
          instance.notify_property_value_change(k, _old, _new)
          pass
        pass
      return
    
    pass #end of class
except: pass
  
try:
  from gobject import GObjectMeta
  class ObservablePropertyGObjectMeta (ObservablePropertyMeta, GObjectMeta): pass
  class ObservablePropertyGObjectMetaMT (ObservablePropertyMetaMT, GObjectMeta): pass    
except:
  class ObservablePropertyGObjectMeta (ObservablePropertyMeta): pass
  class ObservablePropertyGObjectMetaMT (ObservablePropertyMetaMT): pass
  pass


